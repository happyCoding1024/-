<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>二叉树</title>
</head>
<body>
  <script>
    /**
     * 注意：
     * 1）在给树插入节点时假设树是二叉搜索树，即左节点小于父节点，右节点大于父节点，在遍历算法中没有这个前提条件
     * 2）
     * 3）
    */
    class Node {
      constructor (element) {
        this.key = element
        this.left = null
        this.right = null
      }
    }

    class BinarySearchTree {
      constructor () {
        this.root = null
      }
    }

    // 向 BinarySearchTree 中添加方法
    Object.assign(BinarySearchTree.prototype, {
      inOrderTraverse,
      postOrderTraverse,
      preOrderTraverse,
      insert,
      preOrderTraverseNonRecursion
    })

    // 向树中插入一个节点
    function insert (key) {
      const node = new Node(key)
      if (this.root === null) {
        this.root = node
      } else {
        insertNode(this.root, node)
      }

      function insertNode (node, newNode) {
        if (newNode.key < node.key) {
          if (node.left === null) {
            node.left = newNode
          } else {
            insertNode(node.left, newNode)
          }
        } else {
          if (node.right === null) {
            node.right = newNode
          } else {
            insertNode(node.right, newNode)
          }
        }
      }
    }

    // 递归版中序遍历
    function inOrderTraverse (callback) {
      inOrderTraverseNode(this.root, callback)
      function inOrderTraverseNode (node, callback) {
        if (node !== null) {
          inOrderTraverseNode(node.left, callback)
          callback(node.key)
          inOrderTraverseNode(node.right)
        }
      }
    }

    // 递归版先序遍历(前序遍历)
    function preOrderTraverse (callback) {
      preOrderTraverseNode(this.root, callback)
      function preOrderTraverseNode (node, callback) {
        if (node !== null) {
          callback(node.key)
          preOrderTraverseNode(node.left, callback)
          preOrderTraverseNode(node.right, callback)
        }
      }
    }

    // 递归版后序遍历
    function postOrderTraverse (callback) {
      postOrderTraverseNode(this.root, callback)
      function postOrderTraverseNode (node, callback) {
        if (node !== null) {
          postOrderTraverseNode(node.left, callback)
          postOrderTraverseNode(node.right, callback)
          callback(node.key)
        }
      }
    }

    // 非递归版先序遍历
    // 模拟函数递归调用的过程，注意根左右，进栈的时候是右子树先进去，因为先进后出
    function preOrderTraverseNonRecursion() {
      if (!this.root) return;
      const stack = [this.root];
      
      while(stack.length) {
        const n = stack.pop();
        console.log(n.key);
        if (n.right) stack.push(n.right);
        if (n.left) stack.push(n.left);
      }
    } 

    // 测试代码
    const tree = new BinarySearchTree()
    tree.insert(11)
    tree.insert(10)
    tree.insert(12)
    tree.insert(13)
    console.log(tree)
    tree.preOrderTraverseNonRecursion();
  </script>
</body>
</html>